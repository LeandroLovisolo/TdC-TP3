
\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 3 · Teoría de las Comunicaciones}
\rhead{Delgado · Lovisolo · Petaccio}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Insertar gráfico - Inicio %%%%%%%%%%
\newcommand{\grafico}[3]{
  \begin{figure}[H]
    \includegraphics[type=pdf,ext=.pdf,read=.pdf]{#1}
    \caption{#2}
    \label{#3}
  \end{figure}
}
%%%%%%%%%% Insertar gráfico - Fin %%%%%%%%%%


%%%%%%%%%% Palabras clave - Inicio %%%%%%%%%%
\newcommand{\established}{\texttt{ESTABLISHED}\xspace}
\newcommand{\ack}{\texttt{\#ACK}\xspace}
\newcommand{\window}{\texttt{ventana}\xspace}
%%%%%%%%%% Palabras clave - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 3
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Teoría de las Comunicaciones
\end{Large}

\vspace{1cm}

Primer Cuatrimestre de 2014

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Delgado, Alejandro N.  & 601/11 & nahueldelgado@gmail.com\\
Lovisolo, Leandro      & 645/11 & leandro@leandro.me\\
Petaccio, Lautaro José & 443/11 & lausuper@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}
\label{sec:introduccion}


En el presente trabajo se estudia el desempeño del protocolo PTC\footnote{Protocolo desarrollado por la cátedra del curso \emph{Teoría de las Comunicaciones} dictado por el Departamento de Computación de la Universidad de Buenos Aires.} ante algunos fenómenos típicos de una red de área local. El protocolo PTC es un protocolo educacional de capa de transporte que implementa la técnica de ventana deslizante. Los fenómenos estudiados son la latencia y la pérdida de paquetes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Desarrollo                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Desarrollo}
\label{sec:desarrollo}

Se partió de una implementación del protocolo PTC\footnote{Esta implementación fue provista por la cátedra.} a la que se le introdujeron modificaciones para simular los fenómenos estudiados. Luego se realizaron experimentos para medir cómo impactan en el desempeño del protocolo estos fenómenos simulados.


\subsection{Comportamiento de la implementación de PTC}

En lo que sigue se describen algunos escenarios que ocurren al usar la implementación original. La motivación de esto es dar un contexto para las modificaciones que se introducen en \ref{sec:simulacion-fenomenos} y los problemas observados en \ref{sec:problemas-observados}.


\subsubsection{Envío de ACK}

Cuando la conexión está en estado \established y se recibe un paquete con payload, ocurre alguna de las siguientes situaciones:

\begin{itemize}
  \item Se ignora el payload, por ejemplo en caso que la ventana de recepción es nula o que los bytes del payload están fuera de la ventana de recepción.

  \item Se almacena total o parcialmente el payload recibido en el buffer de recepción y se reduce la ventana de recepción en tantos bytes como los que se hayan almacenado en ese buffer.
\end{itemize}

A su vez, en el caso que se almacenan bytes en el buffer de recepción, la implementación notifica al interlocutor enviando un paquete cuyo campo \ack tiene el valor del número de secuencia del próximo byte que se espera recibir y cuyo campo \window indica el nuevo tamaño de la ventana de recepción. Esto puede ocurrir de dos maneras distintas:

\begin{itemize}
  \item Cuando hay datos en el buffer de emisión, se aprovecha el envío del próximo paquete con datos al interlocutor (caso conocido como \emph{piggybacking}.)

  \item Cuando el buffer de emisión está vacío, se envía un paquete sin payload con el único propósito que el interlocutor reciba los valores de los campos \ack y \window.
\end{itemize}

La acción de enviar un paquete sin payload con el único propósito de comunicar la recepción de un paquete proveniente del interlocutor se refiere de ahora en más como \emph{envío de ACK}.


\subsubsection{Envío de paquete de actualización de ventana}

Cuando se leen datos del buffer de recepción, se libera el espacio del buffer previamente ocupado por los datos leídos y se aumenta la ventana de recepción proporcionalmente. Luego se envía al interlocutor un paquete sin payload con el único propósito de comunicar el nuevo valor de la ventana de recepción (campo \window.)

Esto ocurre independientemente de si se tienen datos en el buffer de salida o no.


\subsection{Simulación de los fenómenos estudiados}
\label{sec:simulacion-fenomenos}

Se modificó la implementación del protocolo para simular cada fenómeno de la siguiente manera:

\begin{description}
  \item[Latencia:] Se introduce un retraso en el envío de ACKs. Se suspende la ejecución durante cierta cantidad de tiempo inmediatamente antes del envío de los mismos.

  \item[Pérdida de paquetes:] Se descarta el envío de ACKs al azar, con cierta probabilidad.
\end{description}

Tanto el tiempo de retraso como la probabilidad de pérdida se proveen como parámetros al construir un socket PTC.


\subsection{Problemas observados}
\label{sec:problemas-observados}

Luego de introducir los cambios explicados en \ref{sec:simulacion-fenomenos}, se observaron algunos problemas durante la fase de experimentación que interferían con la correcta ejecución de los experimentos. Estos problemas en algunos casos fueron solucionados y en otros evitados implementando \emph{workarounds}. Explicamos los mismos a continuación.


\subsubsection{Error \texttt{[Errno 90] Message too long} causado por error de cálculo en bloque de control}

Se producía dicho error al intentar enviar un paquete con tamaño mayor a la MTU de Ethernet por medio del socket raw en la clase \texttt{Soquete}.

Este error ocurría porque, bajo ciertas circunstancias, el método \texttt{PTCControlBlock\#usable\_window\_size()} devolvía un valor negativo pequeño.

El valor devuelto por el método anterior representa la cantidad efectiva de bytes del buffer de emisión que se pueden enviar sin inundar al interlocutor. Dicho valor se emplea en el método \\ \texttt{PTCControlBlock\#extract\_from\_out\_buffer(size)} para extraer esa cantidad de bytes del buffer de emisión invocando al método \texttt{DataBuffer\#get(size)}, que recibe dicho valor como parámetro. Luego, los bytes extraídos del buffer se empaquetan como payload de un paquete PTC, y éste se envía al interlocutor. 

En circunstancias normales, el método \texttt{DataBuffer\#get(size)} extrae los primeros \texttt{size} bytes de una lista que contiene los bytes del buffer (tipo de dato \texttt{list} en Python.)

En el caso en el que ocurría el error, dicho método intentaba extraer una cantidad negativa de bytes del buffer, que debido a la semántica de las operaciones con índices en listas en Python, se interpretaba como la extracción de todos los bytes desde la posición 0 hasta \texttt{size} posiciones antes del final de la lista. Además, el buffer almacenaba cientos de miles de bytes al momento de producirse el error. Lo que ocurría finalmente es que se extraía una cantidad de bytes igual al número de bytes en el buffer menos el valor absoluto de \texttt{size}, que como este último era un valor pequeño, resultaba en el orden de los cientos de miles. Cuando luego se intentaba enviar un paquete PTC con un payload de tal tamaño, se producía el error \texttt{[Errno 90] Message too long}, pues la trama Ethernet resultante era de un tamaño muy superior a la MTU de Ethernet, que es de 1500 bytes.

No se encontró la causa de este problema. Sin embargo esta situación dejó de ocurrir luego de parchear el método \texttt{PTCControlBlock\#usable\_window\_size()} de forma que devolviera 0 en caso que el cálculo de ventana efectiva resultara negativo.


\subsubsection{Error \texttt{[Errno 90] Message too long} causado por \emph{maximum segment size} demasiado grande}
\label{sec:error-mss}

Este error ocurría porque por algún motivo cuya causa no se logró identificar, el método \\ \texttt{PTCControlBlock\#usable\_window\_size()} devolvía un tamaño efectivo de ventana de emisión muy grande, que producía que se enviaran paquetes PTC de tamaño superior al de la MTU de Ethernet.

Se logró evitar este problema modificando el valor de la constante \texttt{MSS}, que indica el tamaño máximo de segmento, de forma tal que los paquetes creados nunca superen el tamaño de la MTU.


\subsubsection{Crecimiento del tamaño de la ventana de recepción a medida que pasa el tiempo}

Ocurría que, durante la transmisión de un archivo entre dos hosts por medio de sockets PTC, la ventana de recepción del host que recibía el archivo eventualmente superaba su tamaño inicial y se incrementaba a medida que pasaba el tiempo. No se logró identificar la causa de este problema, pero se sospecha que se trata de un bug de sincronismo entre threads.

Se evitó la ocurrencia de este fenómeno modificando el bloque de control de forma de memorizar el tamaño inicial de la ventana de recepción, y utilizarlo como valor máximo en el método \\ \texttt{PTCControlBlock\#from\_in\_buffer(size)}, que extrae bytes del buffer de recepción e incrementa la ventana de recepción en función de la cantidad de bytes extraídos.

Luego de efectuar este parche, se conjeturó que el error explicado en \ref{sec:error-mss} se producía porque el interlocutor eventualmente recibía un tamaño de ventana de recepción que producía paquetes que superaban la MTU de Ethernet.


\subsubsection{\emph{Deadlock} por recepción de paquete con ventana nula}

En alagunas ocasiones, sucedía durante la transmisión de un archivo entre dos hosts por medio de sockets PTC que el host emisor recibía un paquete con ventana nula, y luego no recibía más paquetes del host receptor. Esto producía que el host emisor quedara perpetuamente a la espera de un paquete con ventana no-nula proveniente del receptor para poder continuar la comunicación, y esto nunca ocurría.

La siguiente es una sucesión de eventos típicas que producía este problema:

\begin{enumerate}
  \item El host receptor tiene ventana de recepción máxima.
  
  \item El host emisor envía un paquete con payload de tamaño igual a la ventana de recepción del host receptor.

  \item El thread de recepción de paquetes del host receptor atiende el paquete recibido, lo almacena en el buffer de recepción y agota la ventana de recepción.

  \item Dicho thread queda suspendido antes de enviar el ACK correspondiente con ventana nula, simulando el fenómeno de latencia.

  \item El thread principal del host receptor, mientras tanto, extrae la totalidad de los bytes en el buffer de recepción, incrementa la ventana de recepción a su valor máximo y envía un paquete de actualización de ventana al host emisor, con valor de ventana máximo.

  \item Inmediatamente después, el thread de recepción de paquetes del host receptor reanuda su ejecución y envía el ACK con ventana nula.

  \item El host emisor recibe un paquete con ventana máxima seguido de otro con ventana nula. Este último anula la ventana de emisión del host emisor. Sin embargo en este instante el nodo receptor tiene ventana de recepción máxima.

  \item El host emisor queda a la espera de un paquete con ventana no-nula proveniente del receptor, pero éste sólo envía paquetes ACK o de actualización de ventana como respuesta a paquetes recibidos del host emisor.
\end{enumerate}

Como se puede observar, el último evento genera una situación de deadlock, en la que ambos hosts quedan perpetuamente a la espera de un paquete de su contraparte antes de volver a enviar nuevos paquetes.

Se solucionó este problema implementando un nuevo thread que envía periódicamente paquetes de actualización de ventana, denominados paquetes \emph{keepalive}, que informan al nodo emisor el valor correcto de ventana de recepción del nodo receptor, lo cual reanuda la transmisión del archivo.


\subsection{Experimentos realizados}
\label{sec:experimentos}

Los experimentos descritos a continuación fueron realizados con una versión del la implementación de PTC que incorpora tanto las modificaciones para simular los fenómenos estudiados, explicadas en \ref{sec:simulacion-fenomenos}, como las soluciones a los problemas descritos en \ref{sec:problemas-observados}.

Se realizó un conjunto de experimentos transmitiendo archivos de distintos tamaños desde un host \emph{cliente} hacia un host \emph{servidor} utilizando sockets PTC. Los experimentos fueron realizados en el contexto de una red LAN donde el cliente se conectaba a un router Linksys WRT54GL de forma inalámbrica (norma 802.11b), mientras que el servidor se conectaba al mismo router de forma cableada (norma 802.3, velocidad 100 Mbits/s.)

En los distintos experimentos se hicieron variar el tiempo de retraso de envíos de ACKs y la probabilidad de pérdida de los mismos en el host servidor, mientras que en el host cliente no se introdujeron retrasos ni pérdidas.

Los experimentos realizados se dividen en dos subconjuntos explicados a continuación.


\subsubsection{Transmisión de archivos de distintos tamaños, sin retraso ni pérdida de ACKs}

Se transmitieron archivos de tamaños siguiendo la secuencia 50 KB, 100 KB, 150KB, 200 KB, \ldots, 950 KB, 1 MB. Se enviaron 10 archivos de cada tamaño, y para cada transmisión se registró el tiempo total de transmisión y la cantidad de retransmisiones de paquetes.


\subsubsection{Transmisión de archivos de tamaño fijo, para distintos tiempos de retraso de envío y probabilidades de pérdida de ACKs}

Se transmitieron 10 archivos de 50 KB para cada par de tiempo de retraso y probabilidad de pérdida de ACKs según las secuencias a continuación:

\begin{itemize}
  \item Tiempos de retraso de envío de ACKs:  0 ms, 5 ms, 10 ms, 15 ms, \ldots, 95 ms, 100 ms.
  \item Probabilidades de pérdida de ACKs: 0, 0.05, 0.1, 0.15, \ldots, 0.45, 0.5.
\end{itemize}

Para cada transmisión se registró el tiempo total de transmisión y la cantidad de retransmisiones de paquetes.






\subsection{Cambios en el código}
Realizamos modificaciones en el código original con el objetivo de arreglar ciertos problemas que encontramos en el transcurso de la experimentación y poder realizar
el registro de eventos interesantes para la experimentación.
s
A continuación, detallaremos los cambios realizados por archivos.

\subsubsection{cblock.py}
Se incluye a la clase PTCControlBlock el objeto max\_rcv\_wnd con el objetivo de solucionar el problema de que la recieve window incremente de tamaño. Para la solución de este problema, se modificó la función from\_in\_buffer() donde ahora se utiliza el nuevo objeto agregado haciendo que efectivamente no se incremente el tamaño de la recieve window.

Por último, modificó la función usable\_window() por el problema de que se realizaba un mal cálculo de la usable window la cual podía devolver un valor negativo.

\subsubsection{constants.py}
Se cambió el valor de MSS por 1024 ya que en redes Ethernet se obtenía un error por enviar paquetes de gran tamaño.

\subsubsection{handler.py}
Se modificó la función send\_ack() para poder realizar la experimentación sobre el protocolo. Se agregó el descarte del paquete ACK utilizando valores aleatorios generados uniformemente utilizando la biblioteca de python random y se agregó para el caso de que el paquete no sea descartado, delay para el mismo.

\subsubsection{protocol.py}
Se agregan a las funciones initialize\_threads(), start\_threads(), stop\_threads() y join\_threads() los handlers para el nuevo thread Keep Alive.

Se crea la función send\_keepalive() la cual se encarga del envío de paquetes keep alive, los cuales continen como información la receive window del emisor que luego será utilizada en el thread keep alive si es necesario.

\subsubsection{ptc\_socket.py}
El constructor de la clase Socket ahora toma los parámetros de delay y probabilida de pérdida para la realización de los experimentos. Para el mismo propósito, el objeto protocol, construido con PTCProtocol ahora se llama en su contruscción con los mismo parámetros.


\subsubsection{soquete.py}
La clase soquete percibe cambios para el registro de errores, en especial el problema en el que se aumentaba la receive window.

\subsubsection{thread.py}
Se agrega la clase KeepAliveSender que funcionará como el nuevo thread agregado para poder solucionar el problema en el que la recepción de una adviced window 0 hace que ambos, receptor y emisor queden esperando la recepción de datos. La función do\_run() de la clase es la encargada de enviar en intervalos, los paquetes keep alive para poder recibir la nueva advice window del receptor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Resultados                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Resultados}
\label{sec:resultados}

\subsection{Distintos tamaños, sin retraso ni pérdida de ACKs}

\grafico{time_vs_size}
        {Tiempo de transferencia en función del tamaño de archivo}
        {plot:time_vs_size}

\grafico{retransmissions_vs_size}
        {Retransmisiones en función del tamaño de archivo}
        {plot:retransmissions_vs_size}

Como puede verse, existen algunos outliers que consideramos que afectan el cálculo de los promedios. Conforman menos del 3\% del total de registros\footnote{Los registros correspondientes a $retransmisiones \ge 10$}, por lo que para tener otra visión sobre el resultado, decidimos realizar el siguiente gráfico sin esos valores.

\grafico{retransmissions_vs_size_wo_outliers}
        {Retransmisiones en función del tamaño de archivo, excluyendo outliers}
        {plot:retransmissions_vs_size_wo_outliers}


\subsection{Tamaño fijo, distintos delays y probabilidades de pérdida de ACKs}

\grafico{time_vs_delay_and_loss_probability}
        {Tiempo de transferencia en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:time_vs_delay_and_loss_probability}

\grafico{retransmissions_vs_delay_and_loss_probability}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:retransmissions_vs_delay_and_loss_probability}

Como sucedía en la figura \ref{plot:retransmissions_vs_size}, aquí también vemos precencia de outliers que afectan nuestros cálculos. Esta vez son menos del 2\% del total\footnote{Se mantiene el valor 10 como límite de retransmisiones}, así que nuevamente procedemos a realizar una representación sin estos registros.

\grafico{retransmissions_vs_delay_and_loss_probability_wo_outliers}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs, excluyendo outliers}
        {plot:retransmissions_vs_delay_and_loss_probability_wo_outliers}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discusión                      			                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Discusión}
\label{sec:discusion}


\subsection{Tiempo de transferencia en función del tamaño del archivo enviado}

En la figura \ref{plot:time_vs_size} podemos observar cómo el tiempo de transferencia crece linealmente al incrementar el tamaño del archivo transmitido. Este comportamiento era el esperado, dado que para archivos cada vez más grandes, las transmisiones requieren proporcionalmente más envíos de paquetes para ser completadas.


\subsection{Retransmisiones en función del tamaño de archivo enviado}

Se obtuvo como resultado de los experimentos realizados sobre retransmisión en función de tamaño del archivo que, salvo unos outliers que pueden identificarse en la figura \ref{plot:retransmissions_vs_size}, la cantidad de retransmisión se mantiene estable en promedio. Puede observarse más detalladamente en la figura \ref{plot:retransmissions_vs_size_wo_outliers}, de la cuál, como el nombre lo indica, fueron eliminados los outliers (retransmisiones eran mayores a 10), que el promedio de retransmisiones cumple con lo dicho.

Este resultado no fue el que esperábamos, ya que al incrementar la cantidad de datos enviados, esperaríamos obtener una cantidad mayor de retransmisiones, siguiendo la idea intuitiva de que en un uso prolongado se repetirían las retransmisiones.

\subsection{Tiempo de transferencia en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}

Observamos en la figura \ref{plot:time_vs_delay_and_loss_probability} dos resultados interesantes. Primero, mientras mayor es el delay de envío de ACKs, mayor es el tiempo total de transferencia del archivo, y segundo, a mayor probabilidad de pérdida de paquetes de ACKs, menor el tiempo de transferencia. Estos resultados resultan contraintuitivoss en relación a nuestro análisis del código. 

Nuestra suposición sobre los resultados a obtener concluía en que, el delay y la pérdida de paquetes, únicamente influyentes en el envío del ACK que se realiza al recibir datos, no afectaría el tiempo de transmisión total debido a que, como en nuestros experimentos el servidor está continuamente leyendo datos del buffer de recepción, instantáneamente después de haber recibido los datos, el servidor los leería (ya que actúa independientemente de la recepción de paquetes) y mandaría el ACK relacionado a la liberación de memoria del buffer, haciendo que el primer ACK (el ACK al recibir datos) no influyera en el tiempo en el que el cliente pueda enviar datos nuevamente debido a que el mismo ya habría recibido la confirmación de la llegada de sus datos con el ACK relacionado al cambio de tamaño de ventana mencionado anteriormente.

Nuestra suposición sobre los resultados observados era que podría llegar a existir algún problema a nivel de implementación, donde los threads que se utilizan estuvieran sufriendo algún lock que dependiera del delay introducido para la experimentación al enviar el ACK, pero nuestro análisis del código descartó la hipótesis dejándonos sin explicación para el fenómeno.


\subsection{Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs} \label{sec:retr_vs_delay_and_loss}

Observamos en la figura \ref{plot:retransmissions_vs_delay_and_loss_probability} y también en la figura \ref{plot:retransmissions_vs_delay_and_loss_probability_wo_outliers} del cúal fueron removidos los outliers (experimentos con 5 o más retransmisiones), que a mayor retraso del envío del ACK al recibir datos por parte del servidor, la cantidad de retransmisiones es, en promedio, estable.

Suponemos que este fenómeno ocurre debido a que, al aplicar delay al ACK que es enviado automáticamente al recibir datos desde el servidor, y como el servidor lee continuamente del buffer de recepción, liberando su receiving windw rápidamente, el ACK con delay es suplantado por el ACK que envía el servidor al liberar su recieving window, haciendo que más tarde, el ACK enviado con delay sea descartado por el cliente el cúal ya habría recibido el ACK con la adviced window liberada haciendo que la necesidad de retransmisión fuera descartada.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusión}

El protocolo PTC, como originalmente fue provisto, contenía una serie de problemas que dificultaban su usabilidad y la experimentación sobre el mismo. Una vez solucionados esos problemas PTC funcionó como protocolo de transporte para los experimentos realizados, de los cuales podemos concluir lo siguiente:

\begin{itemize}
  \item El tiempo de transmisión aumenta linealmente en relación al tamaño del archivo a enviar.
  \item No es posible encontrar una correlación entre la cantidad de retransmisiones y el tamaño de los archivos enviados.
  \item A mayor pérdida de paquetes ACK por datos recibidos, menor tiempo de transmisión de datos.
  \item A mayor delay de paquetes ACK por datos recibidos, mayor tiempo de transmisión de datos.
\end{itemize}

Obviando la primera conclusión propuesta resultante de la experimentación, las demás conclusiones obtenidas no pudieron ser explicadas ya que no fueron encontrados relaciones algunas con la implementación o el uso de la red.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Trabajo futuro                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Trabajo futuro}

Panteamos como trabajo futuro:
\begin{itemize}
\item Una vez corregidos completamente los errores descriptos, realizar nuevamente la experimentación propuesta.
\item Realizar un test más exhaustivo sobre otras anomalías que pudieran existir en una comunicación utilizandose el protocolo, por ejemplo, la pérdida de paquetes y delays en los ACK utilizados para notificar un cambio de ventana al liberar datos del buffer de recepción.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Referencias                                                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{thebibliography}{9}


\end{thebibliography}


\end{document}
