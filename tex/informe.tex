
\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{bytefield}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 3 · Teoría de las Comunicaciones}
\rhead{Delgado · Lovisolo · Petaccio}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Insertar gráfico - Inicio %%%%%%%%%%
\newcommand{\grafico}[3]{
  \begin{figure}[H]
    \includegraphics[type=pdf,ext=.pdf,read=.pdf]{#1}
    \caption{#2}
    \label{#3}
  \end{figure}
}
%%%%%%%%%% Insertar gráfico - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 3
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Teoría de las Comunicaciones
\end{Large}

\vspace{1cm}

Primer Cuatrimestre de 2014

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Delgado, Alejandro N.  & 601/11 & nahueldelgado@gmail.com\\
Lovisolo, Leandro      & 645/11 & leandro@leandro.me\\
Petaccio, Lautaro José & 443/11 & lausuper@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}
\label{sec:introduccion}

Partiendo de la implementación del protocolo de transporte PTC provisto por la cátedra (basado en TCP), se propuso extenderlo para poder introducir y controlar anomalías en la comunicación entre un cliente y un servidor.

Utilizamos estos agregados para poder realizar experimentos con el protocolo y analizar el impacto de las anomalías introducidas. Posteriormente establecemos conclusiones sobre la resistencia y performance de PTC, y por extensión, de TCP.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Desarrollo                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Desarrollo}
\label{sec:desarrollo}


\subsection{Experimentos realizados}

Pendiente.


\subsection{Problemas encontrados}


\subsection{Cambios en el código}
Realizamos modificaciones en el código original con el objetivo de arreglar ciertos problemas que encontramos en el transcurso de la experimentación y poder realizar
el registro de eventos interesantes para la experimentación.

A continuación, detallaremos los cambios realizados por archivos.

\subsubsection{cblock.py}
Se incluye a la clase PTCControlBlock el objeto max\_rcv\_wnd con el objetivo de solucionar el problema de que la recieve window incremente de tamaño. Para la solución de este problema, se modificó la función from\_in\_buffer() donde ahora se utiliza el nuevo objeto agregado haciendo que efectivamente no se incremente el tamaño de la recieve window.

Por último, modificó la función usable\_window() por el problema de que se realizaba un mal cálculo de la usable window la cual podía devolver un valor negativo.

\subsubsection{constants.py}
Se cambió el valor de MSS por 1024 ya que en redes Ethernet se obtenía un error por enviar paquetes de gran tamaño.

\subsubsection{handler.py}
Se modificó la función send\_ack() para poder realizar la experimentación sobre el protocolo. Se agregó el descarte del paquete ACK utilizando valores aleatorios generados uniformemente utilizando la biblioteca de python random y se agregó para el caso de que el paquete no sea descartado, delay para el mismo.

\subsubsection{protocol.py}
Se agregan a las funciones initialize\_threads(), start\_threads(), stop\_threads() y join\_threads() los handlers para el nuevo thread Keep Alive.

Se crea la función send\_keepalive() la cual se encarga del envío de paquetes keep alive, los cuales continen como información la receive window del emisor que luego será utilizada en el thread keep alive si es necesario.

\subsubsection{ptc\_socket.py}
El constructor de la clase Socket ahora toma los parámetros de delay y probabilida de pérdida para la realización de los experimentos. Para el mismo propósito, el objeto protocol, construido con PTCProtocol ahora se llama en su contruscción con los mismo parámetros.


\subsubsection{soquete.py}
La clase soquete percibe cambios para el registro de errores, en especial el problema en el que se aumentaba la receive window.

\subsubsection{thread.py}
Se agrega la clase KeepAliveSender que funcionará como el nuevo thread agregado para poder solucionar el problema en el que la recepción de una adviced window 0 hace que ambos, receptor y emisor queden esperando la recepción de datos. La función do\_run() de la clase es la encargada de enviar en intervalos, los paquetes keep alive para poder recibir la nueva advice window del receptor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Resultados                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Resultados}
\label{sec:resultados}

\grafico{time_vs_size}
        {Tiempo de transferencia en función del tamaño de archivo}
        {plot:time_vs_size}

\grafico{retransmissions_vs_size}
        {Retransmisiones en función del tamaño de archivo}
        {plot:retransmissions_vs_size}

\grafico{retransmissions_vs_size_wo_outliers}
        {Retransmisiones en función del tamaño de archivo, excluyendo outliers}
        {plot:retransmissions_vs_size_wo_outliers}

\grafico{time_vs_delay_and_loss_probability}
        {Tiempo de transferencia en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:time_vs_delay_and_loss_probability}

\grafico{retransmissions_vs_delay_and_loss_probability}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:retransmissions_vs_delay_and_loss_probability}

\grafico{retransmissions_vs_delay_and_loss_probability_wo_outliers}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs, excluyendo outliers}
        {plot:retransmissions_vs_delay_and_loss_probability_wo_outliers}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discusión                      			                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Discusión}
\label{sec:discusion}


\subsection{Tiempo de transferencia en función del tamaño del archivo enviado}

En la figura \ref{plot:time_vs_size} podemos observar cómo el tiempo de transferencia crece linealmente al incrementar el tamaño del archivo transmitido. Este comportamiento era el esperado, dado que para archivos cada vez más grandes, las transmisiones requieren proporcionalmente más envíos de paquetes para ser completadas.


\subsection{Retransmisiones en función del tamaño de archivo enviado}

Se obtuvo como resultado de los experimentos realizados sobre retransmisión en función de tamaño del archivo que, salvo unos outliers que pueden identificarse en el gráfico \textit{Tiempo de transferencia en función del tamaño de archivo} \ref{plot:retransmissions_vs_size}, la cantidad de retransmisión se mantiene estable en promedio. Puede observarse más detalladamente en el segundo gráfico, \textit{Tiempo de transferencia en función del tamaño de archivo, excluyendo outliers} \ref{plot:retransmissions_vs_size_wo_outliers}, del cuál, como el nombre lo indica, fueron eliminados los outliers (retransmisiones eran mayores a 10), que el promedio de retransmisiones cumple con lo dicho.

Suponemos que esto es debido a que, como la pérdida se realiza sobre el primer ACK que envía el servidor al recibir los datos, y como en la experimentación, el servidor está continuamente leyendo datos, la lectura rápida del servidor hará que la ventana de recepción del servidor se libere rápidamente, enviando el ACK que informa la nueva ventana el cuál reemplazará al ACK anterior, sin necesidad de realizar retransmisión por parte del cliente.

\subsection{Tiempo de transferencia en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}

En este resultado hay varios fenómenos interesantes para notar. En principio para todas las probabilidades de pérdida probadas se detecta un crecimiento lineal en el tiempo de transmisión, lo cual es coherente con el incremento en el delay forzado de los ACKs.

Pero algo aún más interesante es el hecho de que los tiempos exhibidos en las pruebas son menores a medida que se incrementa la probabilidad de pérdida introducida. Este resultado es una noción anti-intuitiva, puesto que podría creerse que al perderse más ACKs se incrementaría la cantidad de retransmisiones de paquetes. Como se verá más adelante (\ref{sec:retr_vs_delay_and_loss}), esto no ocurre.

El motivo por el cual se da este fenómeno no nos es claro, pero consideramos como una hipótesis el siguiente comportamiento:

\begin{itemize}
  \item El cliente envía el buffer al servidor.
  \item El servidor, con probabilidad $p$, envía un ACK e indica tamaño de ventana actual.
  \item El cliente continúa envíando paquetes hasta que se termine de transmitir el archivo o el tamaño de ventana comunicado por el servidor sea 0, momento en el cual detiene la transmisión hasta que se libere dicho tamaño de ventana.
\end{itemize}

Al incrementar $p$, esto último ocurre con menor frecuencia, por lo que el cliente continúa enviando paquetes al servidor, y retransmitiendo cuando sea necesario. Como el cliente nunca se bloquea por tamaño de ventana nulo, no existen tiempos ociosos en el proceso de transmisión, o lo que es lo mismo, logra mantenerse el canal de comunicación lo más lleno posible, logrando con ello la reducción del tiempo de transmisión del archivo.


\subsection{Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs} \label{sec:retr_vs_delay_and_loss}

Observamos en la figura \ref{plot:retransmissions_vs_delay_and_loss_probability} y también en la figura \ref{plot:retransmissions_vs_delay_and_loss_probability_wo_outliers} del cúal fueron removidos los outliers (experimentos con 5 o más retransmisiones), que a mayor retraso del envío del ACK al recibir datos por parte del servidor, la cantidad de retransmisiones es, en promedio, estable.

Suponemos que este fenómeno ocurre debido a que, al aplicar delay al ACK que es enviado automáticamente al recibir datos desde el servidor, y como el servidor lee continuamente del buffer de recepción, liberando su receiving windw rápidamente, el ACK con delay es suplantado por el ACK que envía el servidor al liberar su recieving window, haciendo que más tarde, el ACK enviado con delay sea descartado por el cliente el cúal ya habría recibido el ACK con la adviced window liberada haciendo que la necesidad de retransmisión fuera descartada.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusión}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Trabajo futuro                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Trabajo futuro}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Referencias                                                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{thebibliography}{9}


\end{thebibliography}


\end{document}
