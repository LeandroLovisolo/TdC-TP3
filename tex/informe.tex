
\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 3 · Teoría de las Comunicaciones}
\rhead{Delgado · Lovisolo · Petaccio}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Insertar gráfico - Inicio %%%%%%%%%%
\newcommand{\grafico}[3]{
  \begin{figure}[H]
    \includegraphics[type=pdf,ext=.pdf,read=.pdf]{#1}
    \caption{#2}
    \label{#3}
  \end{figure}
}
%%%%%%%%%% Insertar gráfico - Fin %%%%%%%%%%


%%%%%%%%%% Palabras clave - Inicio %%%%%%%%%%
\newcommand{\established}{\texttt{ESTABLISHED}\xspace}
\newcommand{\ack}{\texttt{\#ACK}\xspace}
\newcommand{\window}{\texttt{ventana}\xspace}
%%%%%%%%%% Palabras clave - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 3
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Teoría de las Comunicaciones
\end{Large}

\vspace{1cm}

Primer Cuatrimestre de 2014

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Delgado, Alejandro N.  & 601/11 & nahueldelgado@gmail.com\\
Lovisolo, Leandro      & 645/11 & leandro@leandro.me\\
Petaccio, Lautaro José & 443/11 & lausuper@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}
\label{sec:introduccion}


En el presente trabajo se estudia el desempeño del protocolo PTC\footnote{Protocolo desarrollado por la cátedra del curso \emph{Teoría de las Comunicaciones} dictado por el Departamento de Computación de la Universidad de Buenos Aires.} ante algunos fenómenos típicos de una red de área local. El protocolo PTC es un protocolo educacional de capa de transporte que implementa la técnica de ventana deslizante. Los fenómenos estudiados son la latencia y la pérdida de paquetes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Desarrollo                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Desarrollo}
\label{sec:desarrollo}

Se partió de una implementación del protocolo PTC\footnote{Esta implementación fue provista por la cátedra.} a la que se le introdujeron modificaciones para simular los fenómenos estudiados. Luego se realizaron experimentos para medir cómo impactan en el desempeño del protocolo estos fenómenos simulados.


\subsection{Comportamiento de la implementación de PTC}

En lo que sigue se describen algunos escenarios que ocurren al usar la implementación original. La motivación de esto es dar un contexto para las modificaciones que se introducen en \ref{sec:simulacion-fenomenos} y los problemas observados en \ref{sec:problemas-observados}.


\subsubsection{Envío de ACK}

Cuando la conexión está en estado \established y se recibe un paquete con payload, ocurre alguna de las siguientes situaciones:

\begin{itemize}
  \item Se ignora el payload, por ejemplo en caso que la ventana de recepción es nula o que los bytes del payload están fuera de la ventana de recepción.

  \item Se almacena total o parcialmente el payload recibido en el buffer de recepción y se reduce la ventana de recepción en tantos bytes como los que se hayan almacenado en ese buffer.
\end{itemize}

A su vez, en el caso que se almacenan bytes en el buffer de recepción, la implementación notifica al interlocutor enviando un paquete cuyo campo \ack tiene el valor del número de secuencia del próximo byte que se espera recibir y cuyo campo \window indica el nuevo tamaño de la ventana de recepción. Esto puede ocurrir de dos maneras distintas:

\begin{itemize}
  \item Cuando hay datos en el buffer de emisión, se aprovecha el envío del próximo paquete con datos al interlocutor (caso conocido como \emph{piggybacking}.)

  \item Cuando el buffer de emisión está vacío, se envía un paquete sin payload con el único propósito que el interlocutor reciba los valores de los campos \ack y \window.
\end{itemize}

La acción de enviar un paquete sin payload con el único propósito de comunicar la recepción de un paquete proveniente del interlocutor se refiere de ahora en más como \emph{envío de ACK}.


\subsubsection{Envío de paquete de actualización de ventana}

Cuando se leen datos del buffer de recepción, se libera el espacio del buffer previamente ocupado por los datos leídos y se aumenta la ventana de recepción proporcionalmente. Luego se envía al interlocutor un paquete sin payload con el único propósito de comunicar el nuevo valor de la ventana de recepción (campo \window.)

Esto ocurre independientemente de si se tienen datos en el buffer de salida o no.


\subsection{Simulación de los fenómenos estudiados}
\label{sec:simulacion-fenomenos}

Se modificó la implementación del protocolo para simular cada fenómeno de la siguiente manera:

\begin{description}
  \item[Latencia:] Se introduce un retraso en el envío de ACKs. Se suspende la ejecución durante cierta cantidad de tiempo inmediatamente antes del envío de los mismos.

  \item[Pérdida de paquetes:] Se descarta el envío de ACKs al azar, con cierta probabilidad.
\end{description}

Tanto el tiempo de retraso como la probabilidad de pérdida se proveen como parámetros al construir un socket PTC.


\subsection{Problemas observados}
\label{sec:problemas-observados}

Luego de introducir los cambios explicados en \ref{sec:simulacion-fenomenos}, se observaron algunos problemas durante la fase de experimentación que interferían con la correcta ejecución de los experimentos. Estos problemas en algunos casos fueron solucionados y en otros evitados implementando \emph{workarounds}. Explicamos los mismos a continuación.


\subsubsection{Error \texttt{[Errno 90] Message too long} causado por error de cálculo en bloque de control}

Se producía dicho error al intentar enviar un paquete con tamaño mayor a la MTU de Ethernet por medio del socket raw en la clase \texttt{Soquete}.

Este error ocurría porque, bajo ciertas circunstancias, el método \texttt{PTCControlBlock\#usable\_window\_size()} devolvía un valor negativo pequeño.

El valor devuelto por el método anterior representa la cantidad efectiva de bytes del buffer de emisión que se pueden enviar sin inundar al interlocutor. Dicho valor se emplea en el método \\ \texttt{PTCControlBlock\#extract\_from\_out\_buffer(size)} para extraer esa cantidad de bytes del buffer de emisión invocando al método \texttt{DataBuffer\#get(size)}, que recibe dicho valor como parámetro. Luego, los bytes extraídos del buffer se empaquetan como payload de un paquete PTC, y éste se envía al interlocutor. 

En circunstancias normales, el método \texttt{DataBuffer\#get(size)} extrae los primeros \texttt{size} bytes de una lista que contiene los bytes del buffer (tipo de dato \texttt{list} en Python.)

En el caso en el que ocurría el error, dicho método intentaba extraer una cantidad negativa de bytes del buffer, que debido a la semántica de las operaciones con índices en listas en Python, se interpretaba como la extracción de todos los bytes desde la posición 0 hasta \texttt{size} posiciones antes del final de la lista. Además, el buffer almacenaba cientos de miles de bytes al momento de producirse el error. Lo que ocurría finalmente es que se extraía una cantidad de bytes igual al número de bytes en el buffer menos el valor absoluto de \texttt{size}, que como este último era un valor pequeño, resultaba en el orden de los cientos de miles. Cuando luego se intentaba enviar un paquete PTC con un payload de tal tamaño, se producía el error \texttt{[Errno 90] Message too long}, pues la trama Ethernet resultante era de un tamaño muy superior a la MTU de Ethernet, que es de 1500 bytes.

No se encontró la causa de este problema. Sin embargo esta situación dejó de ocurrir luego de parchear el método \texttt{PTCControlBlock\#usable\_window\_size()} de forma que devolviera 0 en caso que el cálculo de ventana efectiva resultara negativo.


\subsubsection{Error \texttt{[Errno 90] Message too long} causado por \emph{maximum segment size} demasiado grande}
\label{sec:error-mss}

Este error ocurría porque por algún motivo cuya causa no se logró identificar, el método \\ \texttt{PTCControlBlock\#usable\_window\_size()} devolvía un tamaño efectivo de ventana de emisión muy grande, que producía que se enviaran paquetes PTC de tamaño superior al de la MTU de Ethernet.

Se logró evitar este problema modificando el valor de la constante \texttt{MSS}, que indica el tamaño máximo de segmento, de forma tal que los paquetes creados nunca superen el tamaño de la MTU.


\subsubsection{Crecimiento del tamaño de la ventana de recepción a medida que pasa el tiempo}

Ocurría que, durante la transmisión de un archivo entre dos hosts por medio de sockets PTC, la ventana de recepción del host que recibía el archivo eventualmente superaba su tamaño inicial y se incrementaba a medida que pasaba el tiempo. No se logró identificar la causa de este problema, pero se sospecha que se trata de un bug de sincronismo entre threads.

Se evitó la ocurrencia de este fenómeno modificando el bloque de control de forma de memorizar el tamaño inicial de la ventana de recepción, y utilizarlo como valor máximo en el método \\ \texttt{PTCControlBlock\#from\_in\_buffer(size)}, que extrae bytes del buffer de recepción e incrementa la ventana de recepción en función de la cantidad de bytes extraídos.

Luego de efectuar este parche, se conjeturó que el error explicado en \ref{sec:error-mss} se producía porque el interlocutor eventualmente recibía un tamaño de ventana de recepción que producía paquetes que superaban la MTU de Ethernet.


\subsubsection{\emph{Deadlock} por recepción de paquete con ventana nula}

En algunas ocasiones, sucedía durante la transmisión de un archivo entre dos hosts por medio de sockets PTC que el host emisor recibía un paquete con ventana nula, y luego no recibía más paquetes del host receptor. Esto producía que el host emisor quedara perpetuamente a la espera de un paquete con ventana no-nula proveniente del receptor para poder continuar la comunicación, y esto nunca ocurría.

La siguiente es una sucesión de eventos típicas que producía este problema:

\begin{enumerate}
  \item El host receptor tiene ventana de recepción máxima.
  
  \item El host emisor envía un paquete con payload de tamaño igual a la ventana de recepción del host receptor.

  \item El thread de recepción de paquetes del host receptor atiende el paquete recibido, lo almacena en el buffer de recepción y agota la ventana de recepción.

  \item Dicho thread queda suspendido antes de enviar el ACK correspondiente con ventana nula, simulando el fenómeno de latencia.

  \item El thread principal del host receptor, mientras tanto, extrae la totalidad de los bytes en el buffer de recepción, incrementa la ventana de recepción a su valor máximo y envía un paquete de actualización de ventana al host emisor, con valor de ventana máximo.

  \item Inmediatamente después, el thread de recepción de paquetes del host receptor reanuda su ejecución y envía el ACK con ventana nula.

  \item El host emisor recibe un paquete con ventana máxima seguido de otro con ventana nula. Este último anula la ventana de emisión del host emisor. Sin embargo en este instante el nodo receptor tiene ventana de recepción máxima.

  \item El host emisor queda a la espera de un paquete con ventana no-nula proveniente del receptor, pero éste sólo envía paquetes ACK o de actualización de ventana como respuesta a paquetes recibidos del host emisor.
\end{enumerate}

Como se puede observar, el último evento genera una situación de deadlock, en la que ambos hosts quedan perpetuamente a la espera de un paquete de su contraparte antes de volver a enviar nuevos paquetes.

Se solucionó este problema implementando un nuevo thread que envía periódicamente paquetes de actualización de ventana, denominados paquetes \emph{keepalive}, que informan al nodo emisor el valor correcto de ventana de recepción del nodo receptor, lo cual reanuda la transmisión del archivo.


\subsection{Experimentos realizados}
\label{sec:experimentos}

Los experimentos descritos a continuación fueron realizados con una versión del la implementación de PTC que incorpora tanto las modificaciones para simular los fenómenos estudiados, explicadas en \ref{sec:simulacion-fenomenos}, como las soluciones a los problemas descritos en \ref{sec:problemas-observados}.

Se realizó un conjunto de experimentos transmitiendo archivos de distintos tamaños desde un host \emph{cliente} hacia un host \emph{servidor} utilizando sockets PTC. Los experimentos fueron realizados en el contexto de una red LAN donde el cliente se conectaba a un router Linksys WRT54GL de forma inalámbrica (norma 802.11b), mientras que el servidor se conectaba al mismo router de forma cableada (norma 802.3, velocidad 100 Mbits/s.)

En los distintos experimentos se hicieron variar el tiempo de retraso de envíos de ACKs y la probabilidad de pérdida de los mismos en el host servidor, mientras que en el host cliente no se introdujeron retrasos ni pérdidas.

Los experimentos realizados se dividen en dos subconjuntos explicados a continuación.


\subsubsection{Experimento 1: Transmisión de archivos de distintos tamaños, sin retraso ni pérdida de ACKs}

Se transmitieron archivos de tamaños siguiendo la secuencia 50 KB, 100 KB, 150KB, 200 KB, \ldots, 950 KB, 1 MB. Se enviaron 10 archivos de cada tamaño, y para cada transmisión se registró el tiempo total de transmisión y la cantidad de retransmisiones de paquetes.


\subsubsection{Experimento 2: Transmisión de archivos de tamaño fijo, para distintos tiempos de retraso de envío y probabilidades de pérdida de ACKs}

Se transmitieron 10 archivos de 50 KB para cada par de tiempo de retraso y probabilidad de pérdida de ACKs según las secuencias a continuación:

\begin{itemize}
  \item Tiempos de retraso de envío de ACKs:  0 ms, 5 ms, 10 ms, 15 ms, \ldots, 95 ms, 100 ms.
  \item Probabilidades de pérdida de ACKs: 0, 0.05, 0.1, 0.15, \ldots, 0.45, 0.5.
\end{itemize}

Para cada transmisión se registró el tiempo total de transmisión y la cantidad de retransmisiones de paquetes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Resultados                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Resultados}
\label{sec:resultados}

A continuación se presentan los resultados de los experimentos descritos en \ref{sec:experimentos}.


\subsection{Experimento 1: Transmisión de archivos de distintos tamaños, sin retraso ni pérdida de ACKs}
\label{sec:experimento-distintos-tamanos-de-archivo}

\grafico{time_vs_size}
        {Tiempo de transferencia en función del tamaño de archivo}
        {plot:time_vs_size}

\grafico{retransmissions_vs_size}
        {Retransmisiones en función del tamaño de archivo}
        {plot:retransmissions_vs_size}

Los picos que se observan en la figura \ref{plot:retransmissions_vs_size} se deben a la presencia de outliers que creemos son errores de medición.

Para visualizar mejor estos resultados, filtramos todas las transmisiones con cantidad de retransmisiones superior a 10, que representan aproximadamente el 3\% del total de las mediciones. El subconjunto obtenido se ilustra en la figura \ref{plot:retransmissions_vs_size_wo_outliers}.

\grafico{retransmissions_vs_size_wo_outliers}
        {Retransmisiones en función del tamaño de archivo, excluyendo outliers}
        {plot:retransmissions_vs_size_wo_outliers}


\subsection{Experimento 2: Transmisión de archivos de tamaño fijo, para distintos tiempos de retraso de envío y probabilidades de pérdida de ACKs}

\grafico{time_vs_delay_and_loss_probability}
        {Tiempo de transferencia en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:time_vs_delay_and_loss_probability}

\grafico{retransmissions_vs_delay_and_loss_probability}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
        {plot:retransmissions_vs_delay_and_loss_probability}

De manera similar a lo que ocurre en \ref{sec:experimento-distintos-tamanos-de-archivo}, los picos observados en la figura \ref{plot:retransmissions_vs_delay_and_loss_probability} se deben a outliers que suponemos se deben a errores de medición.

En la figura \ref{plot:retransmissions_vs_delay_and_loss_probability_wo_outliers} se excluyen las mediciones con cantidad de retransmisiones superior a 10, que representan aproximadamente el 2\% del total de las mediciones realizadas en este experimento.

\grafico{retransmissions_vs_delay_and_loss_probability_wo_outliers}
        {Retransmisiones en función del retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs, excluyendo outliers}
        {plot:retransmissions_vs_delay_and_loss_probability_wo_outliers}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discusión                      			                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Discusión}
\label{sec:discusion}

Se comentan a continuación algunas observaciones sobre los resultados de los experimentos.


\subsection{Tiempo de transferencia en función del tamaño del archivo}

En la figura \ref{plot:time_vs_size} podemos observar cómo el tiempo de transferencia crece linealmente al incrementar el tamaño del archivo transmitido. Este comportamiento era el esperado, dado que para archivos cada vez más grandes, las transmisiones requieren proporcionalmente más envíos de paquetes para ser completadas.


\subsection{Retransmisiones en función del tamaño de archivo}

Como se observa en la figura \ref{plot:retransmissions_vs_size_wo_outliers}, la cantidad de retransmisiones no parece verse afectada por el tamaño del archivo transmitido. 

Este resultado resultó sorprendente, ya que por la intuición que se tenía acerca del funcionamiento del protocolo, se esperaba la cantidad de retransmisiones fuera proporcional al volúmen de datos enviados.


\subsection{Tiempo de transferencia en función del tiempo de retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}

En la figura \ref{plot:time_vs_delay_and_loss_probability} se observan dos resultados interesantes:

\begin{itemize}
  \item El tiempo de transferencia crece en la medida que crece el tiempo de retraso de envío de ACKs.

  \item El tiempo de transferencia decrece en la medida que crece la probabilidad de pérdida de ACKs.
\end{itemize}

Dado que los únicos paquetes que se retrasan o pierden son los ACKs emitidos por el servidor a medida que recibe paquetes del cliente, en particular, los paquetes de actualización de ventana emitidos por el servidor llegan al cliente sin retrasos ni pérdidas. Dichos paquetes también comunican que se recibieron satisfactoriamente los datos enviados por el cliente (campo \ack.) Por este motivo, tiene sentido suponer que el cliente no debería suspender la transmisión hasta que llegue un ACK demorado para poder continuar, ni tampoco debería perder tiempo retransmitiendo paquetes cuyos ACK fueron perdidos. Es decir, tiene sentido suponer que ambos fenómenos no deberían afectar el tiempo total de transferencia.

Las observaciones mencionadas contradicen esta intuición.

Se realizó un análisis informal del código de la implementación del protocolo, bajo la sospecha que la suspensión del thread de recepción de paquetes antes del envío de un ACK pudiera estar bloqueando el acceso a algún recurso utilizado por los otros threads hasta la reanudación del mismo. Esto explicaría el aumento del tiempo de transferencia a medida que aumenta el tiempo de retraso. Sin embargo este análisis no corroboró dicha sospecha.


\subsection{Retransmisiones en función del tiempo de retraso en envío de ACKs para distintas probabilidades de pérdida de ACKs}
\label{sec:retr_vs_delay_and_loss}

En la figura \ref{plot:retransmissions_vs_delay_and_loss_probability_wo_outliers} no se observa relación alguna entre cantidad de retransmisiones y tiempo de retraso en envío de ACKs, ni entre cantidad de retransmisiones y probabilidad de pérdida de ACKs.

Se cree que la cantidad de retransmisiones no se ve afectada por la probabilidad de pérdida de ACKs ya que los paquetes de actualización de ventana se envían sin retrasos ni pérdida en todos los casos. Estos paquetes le comunican al cliente el número de secuencia del próximo paquete que se espera recibir (campo \ack), del cual se deduce el número de secuencia del último paquete recibido por el servidor, lo que redunda la información de cualquier ACK cuya pérdida fuera simulada por el servidor.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusión}

El protocolo PTC, como originalmente fue provisto, contenía una serie de problemas que dificultaban su usabilidad y la experimentación sobre el mismo. Una vez solucionados esos problemas PTC funcionó como protocolo de transporte para los experimentos realizados, de los cuales podemos concluir lo siguiente:

\begin{itemize}
  \item El tiempo de transmisión aumenta linealmente en relación al tamaño del archivo a enviar.

  \item No es posible encontrar una correlación entre la cantidad de retransmisiones y el tamaño de los archivos enviados.

  \item A mayor pérdida de paquetes ACK por datos recibidos, menor tiempo de transmisión de datos.

  \item A mayor tiempo de retraso de paquetes ACK por datos recibidos, mayor tiempo de transmisión de datos.
\end{itemize}

Obviando la primera conclusión propuesta resultante de la experimentación, las demás conclusiones obtenidas no pudieron ser explicadas ya que no fueron encontrados relaciones algunas con la implementación o el uso de la red.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Trabajo futuro                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Trabajo futuro}

Panteamos como trabajo futuro:

\begin{itemize}
  \item Una vez corregidos completamente los errores descriptos, realizar nuevamente la experimentación propuesta.

  \item Realizar un test más exhaustivo sobre otras anomalías que pudieran existir en una comunicación utilizandose el protocolo, por ejemplo, la pérdida de paquetes y tiempos de retraso en los ACK utilizados para notificar un cambio de ventana al liberar datos del buffer de recepción.
\end{itemize}


\end{document}